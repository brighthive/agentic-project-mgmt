#!/usr/bin/env python3
"""
BrightHive AWS Secrets CLI

Commands:
    sync                        Sync secrets (with values) from AWS into local catalog
    search <query>              Search secrets by name, description, tags
    fetch <name> [field]        Fetch secret value from local catalog (--live for AWS)
    describe <name>             Show secret metadata
    status                      Show catalog stats and health
    accounts                    List account credentials (DynamoDB cross-ref)
"""

import sys
import argparse
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))

from analyzer import SecretsAnalyzer
from app import SecretsApp
from catalog import SecretsCatalog
from config import load_config
from models import SecretCategory, Environment


def _build_app() -> SecretsApp:
    """Factory for creating app instance."""
    config = load_config()
    catalog = SecretsCatalog(catalog_path=config.catalog_path)
    analyzer = SecretsAnalyzer()
    return SecretsApp(
        config=config,
        catalog=catalog,
        analyzer=analyzer,
    )


def cmd_sync(args: argparse.Namespace) -> None:
    """Sync secrets metadata from AWS."""
    app = _build_app()
    envs = args.env if args.env else None

    print(f"Syncing secrets from: {envs or 'all environments'}...")
    result = app.sync(
        environments=envs,
        include_accounts=not args.no_accounts,
        materialize=args.materialize,
    )

    print(f"\nSync complete:")
    print(f"  Environments: {', '.join(result.environments_synced)}")
    print(f"  From Secrets Manager: {result.from_secrets_manager}")
    print(f"  From DynamoDB cross-ref: {result.from_dynamodb_cross_ref}")
    print(f"  Total in catalog: {result.total_secrets}")


def cmd_search(args: argparse.Namespace) -> None:
    """Search secrets."""
    app = _build_app()
    results = app.catalog.search(query=args.query)

    # Optional filters
    if args.env:
        env = Environment(args.env)
        results = [s for s in results if s.environment == env]
    if args.category:
        cat = SecretCategory(args.category)
        results = [s for s in results if s.category == cat]

    if not results:
        print(f"No results for: {args.query}")
        return

    print(f"Found {len(results)} results:\n")
    for secret in results:
        env = f"[{secret.environment.value}]"
        cat = f"({secret.category.value})"
        acct = f" account={secret.account_number}" if secret.account_number else ""
        print(f"  {secret.name} {env} {cat}{acct}")


def cmd_fetch(args: argparse.Namespace) -> None:
    """Fetch secret value from local catalog (or live from AWS with --live)."""
    app = _build_app()

    try:
        value = app.fetch(
            name=args.name,
            field=args.field,
            live=args.live,
            env=args.env,
        )
    except KeyError as e:
        print(str(e), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error fetching secret: {e}", file=sys.stderr)
        sys.exit(1)

    if isinstance(value, dict):
        import json
        print(json.dumps(value, indent=2))
    else:
        print(value)


def cmd_describe(args: argparse.Namespace) -> None:
    """Show secret metadata."""
    app = _build_app()
    results = app.catalog.search(query=args.name)

    if not results:
        print(f"Secret not found: {args.name}", file=sys.stderr)
        return

    if len(results) > 1:
        print(f"Multiple secrets found ({len(results)}):", file=sys.stderr)
        for i, secret in enumerate(results, 1):
            print(f"  {i}. {secret.name} [{secret.environment.value}]", file=sys.stderr)
        return

    secret = results[0]
    print(f"Name:        {secret.name}")
    print(f"ARN:         {secret.id}")
    print(f"Category:    {secret.category.value}")
    print(f"Environment: {secret.environment.value}")
    print(f"Source:      {secret.source.value}")
    if secret.description:
        print(f"Description: {secret.description}")
    if secret.account_number:
        print(f"Account:     {secret.account_name} ({secret.account_number})")
    if secret.account_type:
        print(f"Acct Type:   {secret.account_type}")
    if secret.tags:
        print(f"Tags:        {secret.tags}")
    if secret.created_date:
        print(f"Created:     {secret.created_date}")
    if secret.last_changed_date:
        print(f"Changed:     {secret.last_changed_date}")
    if secret.last_accessed_date:
        print(f"Accessed:    {secret.last_accessed_date}")


def cmd_status(args: argparse.Namespace) -> None:
    """Show catalog stats."""
    app = _build_app()
    status = app.status()

    print(f"Total: {status['total']} secrets")

    if status["by_category"]:
        print("\nBy Category:")
        for cat, count in sorted(status["by_category"].items()):
            print(f"  {cat}: {count}")

    if status["by_environment"]:
        print("\nBy Environment:")
        for env, count in sorted(status["by_environment"].items()):
            print(f"  {env}: {count}")

    if status["by_source"]:
        print("\nBy Source:")
        for src, count in sorted(status["by_source"].items()):
            print(f"  {src}: {count}")

    if status.get("by_account_type"):
        print("\nBy Account Type:")
        for acct_type, count in sorted(status["by_account_type"].items()):
            print(f"  {acct_type}: {count}")

    health = status["health"]
    print(f"\nHealth Score: {health['overall_score']}/100")
    print(f"  Uncategorized: {health['uncategorized_count']}")
    print(f"  Duplicates: {health['duplicate_count']}")
    print(f"  No description: {health['no_description_count']}")


def cmd_accounts(args: argparse.Namespace) -> None:
    """List account credentials."""
    app = _build_app()
    results = app.accounts(account_type=args.type)

    if not results:
        print("No account credentials found.")
        return

    print(f"Found {len(results)} account credentials:\n")
    for secret in results:
        acct_type = f"[{secret.account_type}]" if secret.account_type else ""
        env = f"({secret.environment.value})"
        print(f"  {secret.account_number}  {secret.account_name}  {acct_type} {env}")
        print(f"    Secret: {secret.name}")


def main() -> None:
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="BrightHive AWS Secrets CLI",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # sync
    sync_parser = subparsers.add_parser("sync", help="Sync secrets metadata from AWS")
    sync_parser.add_argument("--env", action="append", choices=["dev", "stg", "prod"], help="Environment(s) to sync")
    sync_parser.add_argument("--no-accounts", action="store_true", help="Skip DynamoDB account cross-ref")
    sync_parser.add_argument("--materialize", action="store_true", help="Write index and metadata files")

    # search
    search_parser = subparsers.add_parser("search", help="Search secrets")
    search_parser.add_argument("query", help="Search query")
    search_parser.add_argument("--env", choices=["dev", "stg", "prod"], help="Filter by environment")
    search_parser.add_argument("--category", help="Filter by category")

    # fetch
    fetch_parser = subparsers.add_parser("fetch", help="Fetch secret value (local catalog or --live from AWS)")
    fetch_parser.add_argument("name", help="Secret name or ARN")
    fetch_parser.add_argument("field", nargs="?", default=None, help="Specific field from JSON secret")
    fetch_parser.add_argument("--env", default="prod", choices=["dev", "stg", "prod"], help="Environment (default: prod)")
    fetch_parser.add_argument("--live", action="store_true", help="Fetch live from AWS instead of local catalog")

    # describe
    describe_parser = subparsers.add_parser("describe", help="Show secret metadata")
    describe_parser.add_argument("name", help="Secret name")

    # find (alias)
    find_parser = subparsers.add_parser("find", help="Find secrets (alias for search)")
    find_parser.add_argument("query", help="Search query")
    find_parser.add_argument("--env", choices=["dev", "stg", "prod"], help="Filter by environment")
    find_parser.add_argument("--category", help="Filter by category")

    # status
    subparsers.add_parser("status", help="Show catalog stats and health")

    # accounts
    accounts_parser = subparsers.add_parser("accounts", help="List account credentials")
    accounts_parser.add_argument("--type", choices=["Organization", "Workspace"], help="Filter by account type")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    commands = {
        "sync": cmd_sync,
        "search": cmd_search,
        "fetch": cmd_fetch,
        "describe": cmd_describe,
        "find": cmd_search,
        "status": cmd_status,
        "accounts": cmd_accounts,
    }

    commands[args.command](args)


if __name__ == "__main__":
    main()
